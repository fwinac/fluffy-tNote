# 数据类型

## 整型

TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间

INT(11) 显示字符的个数。

## 浮点数

DECIMAL 高精度小数、CPU 不原生支持。

设置 float(2,2)，那么写入12.3这个数字时，实际插入的是0.99。

## 字符串

数字是字符长度

**VARCHAR** 

变长、保留空格

## 时间和日期

### DATETIME

8 字节、1001-9999，秒、时区无关。

例如“2008-01-16 22:37:08”

### TIMESTAMP

4 字节、到格林威治午夜秒数、2038 年

# 隔离级别

隔离级别综合应用了封锁、MVCC、Next-Key Locks

## READ UNCOMMITTED

事务中的修改，即使没有提交，对其它事务也是可见的。

## READ COMMITTED

一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

## REPEATABLE READ

保证在同一个事务中多次读取同样数据的结果是一样的。

## SERIALIZABLE

强制事务之间串行执行。

----

| 隔离级别 | 脏读 | 不可重复读 | 幻影读 |
| :------: | :--: | :--------: | :----: |
| 未提交读 |  √   |     √      |   √    |
|  提交读  |  ×   |     √      |   √    |
| 可重复读 |  ×   |     ×      |   √    |
| 可串行化 |  ×   |     ×      |   ×    |

# 封锁
## 封锁粒度

MySQL 中提供了两种封锁粒度：行级锁以及表级锁。

应该尽量只锁定需要修改的那部分数据，而不是所有资源。锁定的数据量越少，发生锁争用的可能就越小，另外，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。

<div align="center"> <img src="pics/1a851e90-0d5c-4d4f-ac54-34c20ecfb903.jpg" width="300"/> </div><br>
## 封锁类型

### 读写锁

- 排它锁（Exclusive），简写为 X 锁，又称写锁。
- 共享锁（Shared），简写为 S 锁，又称读锁。

锁的兼容关系如下：

|  -   |  X   |  S   |
| :--: | :--: | :--: |
|  X   |  ×   |  ×   |
|  S   |  ×   |  √   |

### 意向锁

在存在行级锁的情况下，事务想要对整个表 A 加锁，就需要先检测是否有其它事务对表的任意一行加了锁，非常耗时。

意向锁IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。

- 事务对某行加 S 锁之前，必须先获得表的 IS/IX 锁；
- 事务对某行加 X 锁之前，必须先获得表的 IX 锁。

这样后，只需要检查表有没有意向锁。

## 封锁协议

### 三级封锁协议

**一级封锁协议** 

事务 T 要修改数据 A 时必须加 X 锁，直到**T 结束**才释放锁。

可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

| T<sub>1</sub> | T<sub>2</sub> |
| :-----------: | :-----------: |
|   lock-x(A)   |               |
|   read A=20   |               |
|               |   lock-x(A)   |
|               |     wait      |
|  write A=19   |       .       |
|    commit     |       .       |
|  unlock-x(A)  |       .       |
|               |    obtain     |
|               |   read A=19   |
|               |  write A=21   |
|               |    commit     |
|               |  unlock-x(A)  |

**二级封锁协议**

在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。

可以解决读脏数据问题。

| T<sub>1</sub> | T<sub>2</sub> |
| :-----------: | :-----------: |
|   lock-x(A)   |               |
|   read A=20   |               |
|  write A=19   |               |
|               |   lock-s(A)   |
|               |     wait      |
|   rollback    |       .       |
|     A=20      |       .       |
|  unlock-x(A)  |       .       |
|               |    obtain     |
|               |   read A=20   |
|               |  unlock-s(A)  |
|               |    commit     |

**三级封锁协议** 

在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。

可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。

| T<sub>1</sub> | T<sub>2</sub> |
| :-----------: | :-----------: |
|   lock-s(A)   |               |
|   read A=20   |               |
|               |   lock-x(A)   |
|               |     wait      |
|   read A=20   |       .       |
|    commit     |       .       |
|  unlock-s(A)  |       .       |
|               |    obtain     |
|               |   read A=20   |
|               |  write A=19   |
|               |    commit     |
|               |  unlock-X(A)  |

### 两段锁协议

加锁和解锁分为两个阶段进行。

可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。

事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。

```html
lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
```

但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。

```html
lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
```

## MySQL 隐式与显示锁定

会根据**隔离级别**在需要的时候自动加锁，并且所有的锁都是在**同一时刻**被释放，这被称为隐式锁定。

InnoDB 也可以使用特定的语句进行显示锁定：

```sql
SELECT ... LOCK In SHARE MODE;
SELECT ... FOR UPDATE;
```

# 多版本并发控制

多版本并发控制，用于高效实现提交读和可重复读。

## 版本号

- 系统版本号：每开始一个新事务，系统版本号就递增。
- 事务版本号：事务开始时的系统版本号。

## 隐藏的列

每行记录后面都保存着两个隐藏的列

- 创建版本号：指创建一个数据行的快照时的系统版本号；
- 删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。

## Undo 日志

MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。

<div align="center"> <img src="pics/e41405a8-7c05-4f70-8092-e961e28d3112.jpg" width=""/> </div><br>
## 实现过程

以下实现过程针对可重复读隔离级别。

当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号。

### UPDATE

将当前**系统版本号**作为更新前的**数据行最新快照的**删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。不是在事务所读取到的快照基础上改的。

### SELECT

读取创建版本号小于**事务版本号**，而删除版本号大于事务版本号的快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。

### INSERT

将当前系统版本号作为数据行快照的创建版本号。

### DELETE

将当前系统版本号作为数据行快照的删除版本号。

## 快照读与当前读

### 快照读

使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。

```sql
select * from table ...;
```

### 当前读（locking read）

读取的是最新的数据，需要加锁。

```sql
select * from `user` where `id`=301 lock in share mode;
select * from table where ? for update;
```

**下面的操作也是当前读**

```sql
insert;
update;
delete;
```

# Next-Key Locks

MVCC 不能解决幻读的问题，Next-Key Locks 就是为了高效解决这个问题而存在的。

## Record Locks

锁特定行的索引。

主键会隐式创建索引。

如果还没索引，就锁表。

## Gap Locks

锁定**索引之间的间隙**。

```sql
# 如果索引的值有 8，19。那么 8 到 19 的间隙是不允许插入数据的。
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

## Next-Key Locks

它是 Record Locks 和 Gap Locks 的结合，不仅锁定特定记录，也锁定间隙。

参考：https://blog.csdn.net/cug_jiang126com/article/details/50596729

# B+ Tree

多叉平衡（Balance）查找树。

- 节点多键，非递减（递增/等），指向皆小
- 叶同层，所有键、数据，
- 叶相连


<div align="center"> <img src="pics/10a6d3ee-04b2-46b4-b171-d596e5ab0f84.jpg"/> </div><br>
## 红黑树

磁盘 IO 更少，IO 速度更快

`参考`

- 聚簇索引和辅助索引？
- 哈希索引
- 全文索引

# 优化

- SQL 语句优化：查少量数据、尽量使索引生效，尽量使用索引的数据

  - 尽量使索引生效：建立索引（前缀，选择性）、使用上索引

- 缓存；读缓存，写缓存。

- 读写分离

  原因：增加服务器优化、读优化、锁争用

  复制原理：binlog 线程、io 线程、sql 线程、日志恢复

- 垂直切分

  统一多个服务（一个表包含订单和用户数据）到多处服务，每处服务性能提高。专门对读优化。

- 水平切分（分片）
  
  插入、查询、整体服务
  选择分片：哈希、范围、
  `问题`
  ID 唯一、事务、连接
  
- Explain 分析

  类型、行数

`参考`

- 生成ID：集中，分布式（域）

- snowflake：唯一标识+时间戳+自增

# 引擎

外键、事务、锁、备份、崩溃、MyISAM 特性

# 问题

- 不使用索引？

  字符串

  如 !=、<>、not，表达式一部分

  最左前缀，like 通配符

  使用 or 连接条件

  函数参数

- 整形、字符串，哪种索引快？

  呈现转存储