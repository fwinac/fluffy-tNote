# Monolith 的缺点

- 不能为特定功能选择合适的技术栈。
- 协调花费大；当业务很复杂时，需要多个（乃至多种）开发人员协同开发。在单体应用里，由于代码之间是“强耦合”，即使使用 Maven 进行模块化开发，为了理解他人代码和避免引入错误（如别人依赖自己的代码），开发人员之间的协调沟通仍要花费大量时间。
- 新功能或修复上线速度慢；单体应用上线需要多个开发人员“对齐”进度；小的修改也需要整体的编译部署。
- 整体稳定性差；整个应用会因为某个部分的问题无法运行。
- 难以有针对的进行扩展。

# 微服务

程序拆成了一个个服务，每个服务运行在独立的**进程**中。服务之间则通过进程间通信来调用。

微服务拆分对架构设计提出了更高的要求：哪些应该划分到一个服务？服务之间调用失败后怎么处理？

服务拆分后，每个服务由一个“小团队”负责，沟通效率提升。

服务拆分后，每个服务可能都需要一些相同的基础功能，比如数据库访问、工具类，这些会造成重复。而且，每个服务相对独立，可能会相对独立的进行数据存储，这会使整个系统无法遵循数据的强一致性。

服务的变多，对运维提出了更高的要求。要自动化部署，要完善的日志、监控、链路追踪。

# 微服务组件

- 服务注册和服务发现

  如果服务之间要调用，调用者需要知道被调的地址信息。一个简单的解决方法，我们可以把所有提供该功能的被调的地址信息写入调用者的配置文件。但是当一些被调宕机后，调用者无法及时发现，将进行无效的调用。

  这时候，我们可以引入一个“中间人”（即注册中心），“中间人”有所有服务的标识和地址的对应关系，并维护这些关系的正确性。这时，我们通过“服务发现”从“中间人”获取目标的地址就不再有上面的问题。

  实现注册中心的技术有：Consul，ZooKeeper，Etcd，Eureka 等。

- 健康检查

  在上面过程中，注册中心是怎么发现某些服务运行的机器不正常？这时候就需要健康检查，它检查服务所在服务器的运行状态及服务本身的运行状态。

  实现健康检查的技术有 Consul，Spring Boot，Actuator 等。

- 配置管理

  在服务中自己维护配置信息，不利于配置的动态变化。这时候我们也可参考注册中心的方式，引入“中间人”来放配置信息。且由于配置的分离，也可让线上运行环境只有尽可能少的人知道，带来一定的安全性。

  Consul、Archaius 可用来实现配置管理。
  
- 服务通信

  服务之间的通信方式一般上来说可以直接使用 TCP，也可使用 HTTP。HTTP 操作起来比较方便。

  常见用于通信的技术有：Netty、Retrofit、OkHttp、AsyncHttpClient等。
  
- 服务路由

  当从注册中心取出目标服务器列表后，之后需要一定的负载均衡策略（路由策略）从这些服务器中选出一台，服务路由负责选择过程。

  常见的实现有 Ribbon。

- 服务容错

  服务可能因为各种原因变得不可用，怎么保证不会因为一个服务宕机了，部分乃至整个系统不可用。甚至实现将不可用服务变得可用，这就需要服务容错。

  常见的实现是 Hystrix。

- 日志系统

  日志可能散落在各台机器上，不太方便查看，这时候就需要把它们收集起来，就需要日志系统。

  常见的实现有：Logback、ELK、Redis、Kafka、Hadoop等。

- 全链路追踪系统

  一个具体的业务过程需要多个服务来完成。当这个过程运行不正常的时候，我们需要找出问题点。这时候就要理清服务之间的依赖关系，即调用链，但是如果只单单是展示调用链信息，如果调用链比较长，也比较难以找出关键，所以，最好是用图形来展示这个过程。

  常见的实现有：Zikpin、Brave、Spring Cloud Sleuth等。

- 计数监控系统

  服务运行过程中，为了把服务调到最优，我们需要监控服务运行的数据指标，如：CPU 使用率、内存占用率等。

  常见的实现有：Promethus、Hystrix-Dashboard、Graphite 等。

- 文档输出

  我们需要把 API 展示给使用者，这时候就需要文档。手动维护 Word，需要大量精力，而且容易出错。当 API 参数变动的时候，修改旧文档也比较麻烦。这时候就需要一种工具，通过简单的配置，就能自动生成文档。

  常见的实现有：Swagger 等。

- 持续继承与持续部署系统

  当要发布一个服务时，我们需要编译、打包、上传、运行，效率极低。特别是当这些服务很多的时候。这时候就需要工具自动完成这些过程。

  常见的有：GitLab、Jenkins、Docker、k8s 等。

- 服务网关

  外部请求一个服务的时候，我们需要一个“中间人”把这个请求交给合适的服务，这个“中间人”要干的就是路由转发。

  > 和注册中心有什么区别？
  
   通常来说，所有服务都依赖一些公共功能，比如权限验证。我们可以每个服务都实现一下这个功能，但是这样太冗余了。那么我们还可以让所有服务委托同一个服务进行权限验证，但是这样的话，权限验证对所有服务都是已知的，这样也不太好。
  
  这时，可在请求和服务之间加一个“中间人”，所有请求都必须先通过这个“中间人”，“中间人”来进行权限认证。通过后，请求才会到达服务，这样权限认证对服务是不可知的。
  
  服务网关实现了上面的两个功能：路由转发+过滤器。
  
  常用来实现的技术有：Zuul、Kong 等。
  
- 服务编排

  服务运行的时候我们需要根据运行情况调整运行状态。比如：一个 service 需要三个容器实例；当 CPU 使用率到 90% 的时候，要再启动一个容器。我们可以使用服务编排自动完成这些功能。

  常用的实现有：k8s。

# Spring Boot

相比传统 Spirng，Spring 可以：

1. 不需要再手动为一些基础功能导一系列的包，并解决版本冲突问题，可以直接使用 starter。
2. 不需要再为一些框架手动进行通用配置，Spring Boot 可以自动为它们配置。
3. 不需要单独建立配置文件，只需要注解就可以。
4. 不需要打包后再放到服务器程序运行，生成的 jar 包直接就可用。

>spring-boot-maven-plugin 的作用
>
>Maven 生成的 jar 包因为缺少一些资源，还没办法直接运行。该 plugin 可以为 Maven 生生成的 jar 包二次打包，得到一个“fat-jar”包，这样就可以直接运行了。