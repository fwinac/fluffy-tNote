# 必要条件

<div align="center"> <img src="pics/c037c901-7eae-4e31-a1e4-9d41329e5c3e.png"/> </div><br>
- 互斥(Mutual Exclusion)：一个资源一次只能一个进程使用。
- 请求与保持(Hold And Wait)：已经得到了某个资源的进程可以再请求新的资源。
- 不可抢占(Not Preemption)：已经分配给进程的资源不能被抢占。
- 环路等待（Circular Wait)：若干进程申请使用资源形成循环等待。

`参考`

- 死锁的间接原因？
  操作系统的并发特性
- 资源分配图
圆圈表示进程，方框表示资源；进程指向表示请求某个资源，被指向，拥有某个资源。
- 请求与保持也常叫部分分配，即没分配完进程全部需要的资源。

# 处理方法

# 鸵鸟策略

把头埋在沙子里，假装根本没发生问题。

因为解决死锁问题的代价很高；当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。

# 死锁预防

在程序运行之前预防发生死锁。

## 破坏互斥条件

用程序模拟临界资源，这个模拟程序是同时共享的。

## 破坏占有和等待条件

规定所有进程在开始执行前请求所需要的全部资源，避免进程获得资源后又去请求资源。

## 破坏不可抢占条件

## 破坏环路等待

给资源依次按序编号，进程只能按编号顺序请求资源。

# 死锁避免

在程序运行时避免发生死锁。

## 安全状态

<div align="center"> <img src="pics/ed523051-608f-4c3f-b343-383e2d194470.png"/> </div><br>

图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。

定义：即使所有进程突然请求对资源的最大需求，也仍然存在某种资源分配次序能使所有进程运行完毕，则称该状态是安全的。

## 单类资源的银行家算法

一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断此时是否是不安全状态，如果是，就拒绝贷款。

<div align="center"> <img src="pics/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png"/> </div><br>

## 多类资源的银行家算法

<div align="center"> <img src="pics/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png"/> </div><br>

上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。

检查一个状态是否安全的算法如下：

- 如果有进程没标记，在右边矩阵里没标记的进程中查找是否存在**一行**小于等于向量 A。如果没有进程没标记，安全状态。
- 假设没有这样一行，此状态不安全
- 假若找到，将该进程标记为终止，并将其已分配资源加到 A 中。
- 重复以上两步。

多类资源由一次**满足一类**变成了一次**满足多类**。

# 死锁检测与死锁恢复

不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

## 每种类型一个资源的死锁检测

<div align="center"> <img src="pics/b1fa0453-a4b0-4eae-a352-48acca8fff74.png"/> </div>

图 a 和图 b都有环，发生死锁。

从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。

## 每种类型多个资源的死锁检测

<div align="center"> <img src="pics/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png"/> </div><br>

进程 P<sub>1</sub> 和 P<sub>2</sub> *(第一行为P<sub>1</sub>)*所请求的资源都得不到满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。

## 死锁恢复
- 剥夺资源
- 进程中止

所谓资源抢占是指从**死锁进程**那里抢占资源，此时必须考虑三个问题：
1. 选择一个“低代价”的牺牲品 
2. 回滚到安全状态 
3. 饥饿（在代价因素中加上回滚次数，回滚的越多则越不能继续作牺牲品）

  


