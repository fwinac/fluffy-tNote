
# 三大特性

## 封装

- 类的**所有信息**能通过多种方式获取，且当类本身变动后，可能不小心破坏了其他地方的“依赖”以及类本身的一致性。
- 解决：只暴露几个明显的的接口（业务）；慎重暴露 getter 和 setter，他们往往向外”8展示“的不是一种操作。
- 特点：暴露少数接口也让操作起来更不容易出错

## 抽象

- 起源

  - 函数的名字，内容太具体了，当一个这类操作（函数）变成另一个，就得改名字，改定义
  - 代码依赖具体的实现，导致这段代码不能复用
- 解决
  - 避免被引用者太具体，如出现 ali，tencent 等等
  - 接口（命名加字母 I）

## 继承

继承实现了  **IS-A**  关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。

继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。

Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为  **向上转型** 。

```java
Animal animal = new Cat();
```

继承在理论上有：单继承和多继承，Java 只支持单继承；菱形继承问题。

>注：菱形继承的两个”中间类“都继承了“顶类”的同一方法，所以“底层类"调用时不知道是哪一个类。这时，可采用”虚继承”，中间类”所谓继承“的方法只是对父类方法的一个指针，这样调用时就不会有矛盾。


使用继承，如果继承层级过深，可能造成可读性较差。


为了解决这个问题，可以采用”接口+组合+委托“。但是，组合起来的多个类，在方法上是不同的。外部使用的时候，该怎么知道某个类是否有某个方法呢？可以让这些类除了组合”行为接口“，自己本身也要实现那个接口，则外部使用时要基于抽象。

## 多态

多态分为编译时多态和运行时多态：

- 编译时多态主要指方法的重载
- 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定

运行时多态有三个条件：

- 继承
- 覆盖（重写）
- 向上转型

运行时多态，还有两种实现方式：接口实现， duck-typing

C++ 不支持接口类语法。duck-typing 只有一些动态语言才支持，比如 Python、JavaScript 等，且各个“实现者”之间没有关系。

“多态是实现代码尽可能抽象的基础”

# 贫血模型和充血模型

贫血模型数据和代码分离，repository 取出 Entity 传到 Service，Service（业务逻辑层） 返回 Bo 到 controller，controller 返回 Vo。这个过程简单且常用，适合简单的业务逻辑。充血模型，如 DDD，将业务逻辑放到 domain 中，一般用于复杂业务逻辑。

## 充血模型

一般来说，使用”领域模型“（Domain），主要优势有：

1. 不容易出错，因为”模型"只向外提供有限的接口。
2. 因为业务逻辑集中到了模型中，复杂业务逻辑的可读性和可维护性增加。

为什么还要保留 Service 层？Service 层留着和其他部分打交道，如 Repository，日志等。另外 Service 可用于聚合多个 Domain，当然也可以再创建一个 Domain 实现这个聚合功能。

为什么只在 Service 层抽取领域模型？Controller 返回的 VO 是一种 DTO，专门用于传输数据的，不须加入业务逻辑。Repository 返回的 Entity 到 Service 层直接转换为 BO 或者 Domain，生命周期很短，不会对它进行多余操作。

# UML 类图

![](pics/20200118203601.jpg)

为了符合“组合优于继承”中“组合”的含义，将组合（成员变量、强烈依赖、构造器中初始化），聚合（成员变量、较弱、从参数传入），关联合并为“组合”。故现在主要有四种关系：泛化、实现、组合、依赖。

注意依赖包含组合，且包括对象用作返回值，参数等。

# 设计思想

- 封装对象传参

  将各个参数封装成类来传入。

- 引入 handler

  将方法内部流程变成遍历执行 handler。

# 设计原则

## S.O.L.I.D

| 简写 | 全拼 | 中文翻译 |
| :--: | :--: | :--: |
| SRP | The Single Responsibility Principle    | 单一责任原则 |
| OCP | The Open Closed Principle              | 开放封闭原则 |
| LSP | The Liskov Substitution Principle      | 里氏替换原则 |
| ISP | The Interface Segregation Principle    | 接口分离原则 |
| DIP | The Dependency Inversion Principle     | 依赖倒置原则 |

### 单一责任原则

> A class or module should have a single reponsibility.

拆分的目的是为了**高内聚**、低耦合

注意：

1. 类或方法中又有一大块为了完成“某个子功能”。
2. 类中的某一部分重要性增加。
3. 过度拆反而会造成内聚变弱。

### 开放封闭原则

> software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification.

添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等），即要求修改没有破坏原有的单元测试等。

### 里氏替换原则

> 子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。

“Design By Contract”，父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。

例：

1. 如果子类中抛出了新的异常，不符合 LSP

### 接口隔离原则

> Clients should not be forced to depend upon interfaces that they do not use.

调用者只使用部分接口或接口的部分功能就不符合 ISP。如接口之间有安全性要求差异、函数的功能过多。

### 依赖倒置原则

> 高层模块不应该依赖于低层模块，二者都应该依赖于抽象；</br>抽象不应该依赖于细节，细节应该依赖于抽象。

高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。

依赖于抽象意味着：

- 任何变量都不应该持有一个指向具体类的指针或者引用；
- 任何类都不应该从具体类派生；
- 任何方法都不应该覆写它的任何基类中的已经实现的方法。

## 其他常见原则

除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。

| 简写    | 全拼    | 中文翻译 |
| :--: | :--: | :--: |
|LOD|    The Law of Demeter                   | 迪米特法则   |
|CRP|    The Composite Reuse Principle        | 合成复用原则 |
|CCP|    The Common Closure Principle         | 共同封闭原则 |
|SAP|    The Stable Abstractions Principle    | 稳定抽象原则 |
|SDP|    The Stable Dependencies Principle    | 稳定依赖原则 |

### 迪米特法则

迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。

### 合成复用原则

尽量使用对象组合，而不是通过继承来达到复用的目的。

### 共同封闭原则

一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。

### 稳定抽象原则

最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。

### 稳定依赖原则

包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。

