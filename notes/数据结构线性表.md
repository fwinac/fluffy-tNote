## 数组

- 随机访问

  随机访问为 O(1)
  
- 越界

  ```c
  int main(int argc, char* argv[]){
      int i = 0;
      int arr[3] = {0};
      for(;i<=3;i++){
          arr[i] = 0;
          printf("hello world\n");
      }
      return 0;
  }
  ```

- “低效“的修改

  1. 减少修改的代价：交换
  2. 减少修改的次数：要删除时只是标记，直到不得不删了


- 和”容器“（ArrayList）的比较

  1. 容器封装了操作的细节；如，修改过程中的内存申请和搬运过程就被隐藏了。
  2. 自动扩容；不过，如果知道数据大小，要指定ArrayList初始大小
  3. ArrayLIst 无法存储基本类型
  4. 性能损耗

- 下标

  数组的下标应该理解为偏移（offest）。对数组 a 来说，a 表示数组首地址，a[0]表示偏移为 0 的地址，a[k] 表示偏移为 k 个 type_size 的位置。

## 链表

- 特殊链表

  循环链表；当要处理的数据有环形结构特点时，适合循环链表，如约瑟夫问题。

  双向链表：在O(1)时间找到前驱；带来以下优势：

  在删除指定节点或在指定节点前插入时效率更高。而且当链表有序时，查找也可以更高效，记录上次查找的节点，下次查找根据大小，向前或向后查找。

- 和数组比较

  一块固定连续内存（预读）、操作

- 应用场景

  LRU 缓存。

  缓存清理的方式？（随身带的箱子满了怎么清理？）